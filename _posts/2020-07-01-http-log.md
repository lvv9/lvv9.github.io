# Spring MVC、RestTemplate、Postman实验记录

1. 案例一

操作  
> - Spring MVC启动服务端  
> - Postman发送正常的HTTP GET请求

实验结果  
> - 三次握手  
> - GET请求及ACK  
> - 分成两帧GET响应及ACK  
> - 客户端Keep-Alive及ACK  
> - 服务端FIN及ACK  
> - 客户端继续两次Keep-Alive及ACK  
> - 服务端RST  
> - 客户端自始至终都使用同一端口  
> - 完

2. 案例二

操作  
> - Spring MVC启动服务端  
> - Postman发送正常的HTTP GET请求  
> - 服务端FIN前停止服务

实验结果  
> - 三次握手  
> - GET请求及ACK  
> - 分成两帧GET响应及ACK  
> - 客户端Keep-Alive及ACK  
> - 服务端RST  
> - 客户端自始至终都使用同一端口  
> - 完

3. 案例三

操作  
> - Spring MVC启动服务端  
> - Postman发送header带Connection=close的HTTP GET请求（抓包发现Connection还是keep-alive……）

实验结果同案例一

4. 案例四

操作  
> - Spring MVC启动服务端  
> - Postman发送异常的HTTP GET请求（服务端处理异常）

实验结果  
> - 三次握手  
> - GET请求及ACK  
> - 分成两帧GET响应及ACK  
> - 四次挥手  
> - 客户端自始至终都使用同一端口  
> - 完

5. 案例五

操作  
> - Spring MVC启动服务端  
> - Postman发送正常的HTTP GET请求  
> - Postman紧接着发送异常的HTTP GET请求  
> - Postman紧接着发送正常的HTTP GET请求

实验结果  
> - 三次握手  
> - GET请求及ACK  
> - 分成两帧GET响应及ACK  
> - GET请求及ACK  
> - 分成两帧GET响应及ACK  
> - 四次挥手  
> - 客户端使用新的端口执行正常的HTTP GET请求  
> - 完

6. 案例六

操作  
> - Spring MVC启动服务端  
> - Postman发送正常https协议的HTTP GET请求

实验结果  
> - 三次握手  
> - GET请求及ACK  
> - 客户端发送带PSH的包、服务端ACK  
> - 服务端发送带PSH的包、客户端ACK  
> - 来来回回几次客户端ACK后服务端发送PSH、客户端ACK（PSH这些应该是证书、密钥相关的流程）  
> - 15秒后客户端FIN及ACK  
> - 服务端PSH  
> - 客户端RST  
> - 然后新的端口三次握手到客户端FIN前又执行了一遍  
> - 客户端不FIN、发送带PSH的包、服务端ACK  
> - 服务端两次PSH及ACK  
> - 客户端Keep-Alive及ACK  
> - 服务端PSH及ACK  
> - 服务端FIN及ACK  
> - 客户端继续两次Keep-Alive及ACK  
> - 服务端RST  
> - 完

7. 案例七

操作  
> - Spring MVC启动服务端  
> - Postman发送正常https协议的HTTP GET请求  
> - 客户端Keep-Alive前Postman发送正常https协议的HTTP GET请求

实验结果除了在第一次Keep-Alive前增加了客户端一次PSH、服务端两次PSH外与案例六一样

8. 案例八

操作  
> - Spring MVC启动服务端  
> - Postman发送正常https协议的HTTP GET请求  
> - 服务端Keep-Alive ACK后Postman发送正常https协议的HTTP GET请求

实验结果除了在第一次Keep-Alive ACK后增加了客户端一次PSH、服务端两次PSH、客户端Keep-Alive外与案例六一样

9. 案例九

操作  
> - Spring MVC启动服务端  
> - Postman发送正常https协议的HTTP GET请求  
> - 客户端FIN ACK后Postman发送正常https协议的HTTP GET请求

实验结果  
> - 客户端FIN ACK及之前与案例六相同  
> - 客户端FIN及ACK
> - 客户端使用新的端口执行正常https协议的HTTP GET请求  
> - 完
